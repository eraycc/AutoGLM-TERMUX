from __future__ import annotations

import os
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any


def _autoglm_home() -> Path:
    return Path(os.environ.get("AUTOGLM_HOME", str(Path.home() / ".autoglm"))).expanduser()


def config_sh_path() -> Path:
    return _autoglm_home() / "config.sh"


_DEFAULTS = {
    "PHONE_AGENT_BASE_URL": "https://open.bigmodel.cn/api/paas/v4",
    "PHONE_AGENT_MODEL": "autoglm-phone",
    "PHONE_AGENT_API_KEY": "sk-your-apikey",
    "PHONE_AGENT_MAX_STEPS": "100",
    "PHONE_AGENT_DEVICE_ID": "",
    "PHONE_AGENT_LANG": "cn",
}


def _strip_inline_comment(line: str) -> str:
    in_single = False
    in_double = False
    escaped = False
    out = []
    for ch in line:
        if escaped:
            out.append(ch)
            escaped = False
            continue
        if in_double and ch == "\\":
            out.append(ch)
            escaped = True
            continue
        if ch == "'" and not in_double:
            in_single = not in_single
            out.append(ch)
            continue
        if ch == '"' and not in_single:
            in_double = not in_double
            out.append(ch)
            continue
        if ch == "#" and not in_single and not in_double:
            break
        out.append(ch)
    return "".join(out).strip()


def _parse_shell_concat(value: str) -> str:
    value = value.strip()
    i = 0
    out: list[str] = []
    while i < len(value):
        ch = value[i]
        if ch.isspace():
            break
        if ch == "'":
            j = value.find("'", i + 1)
            if j == -1:
                out.append(value[i + 1 :])
                break
            out.append(value[i + 1 : j])
            i = j + 1
            continue
        if ch == '"':
            i += 1
            buf: list[str] = []
            while i < len(value):
                ch2 = value[i]
                if ch2 == '"':
                    i += 1
                    break
                if ch2 == "\\" and i + 1 < len(value):
                    nxt = value[i + 1]
                    if nxt in ['"', "\\", "$", "`", "\n"]:
                        buf.append(nxt)
                        i += 2
                        continue
                buf.append(ch2)
                i += 1
            out.append("".join(buf))
            continue
        j = i
        while j < len(value) and not value[j].isspace() and value[j] not in ["'", '"']:
            j += 1
        out.append(value[i:j])
        i = j
    return "".join(out)


def _shell_single_quote(value: str) -> str:
    if value == "":
        return "''"
    return "'" + value.replace("'", "'\"'\"'") + "'"


@dataclass
class AutoglmConfig:
    base_url: str
    model: str
    api_key: str
    max_steps: str
    device_id: str
    lang: str

    @classmethod
    def from_mapping(cls, data: dict[str, str]) -> "AutoglmConfig":
        return cls(
            base_url=data.get("PHONE_AGENT_BASE_URL", _DEFAULTS["PHONE_AGENT_BASE_URL"]),
            model=data.get("PHONE_AGENT_MODEL", _DEFAULTS["PHONE_AGENT_MODEL"]),
            api_key=data.get("PHONE_AGENT_API_KEY", _DEFAULTS["PHONE_AGENT_API_KEY"]),
            max_steps=data.get("PHONE_AGENT_MAX_STEPS", _DEFAULTS["PHONE_AGENT_MAX_STEPS"]),
            device_id=data.get("PHONE_AGENT_DEVICE_ID", _DEFAULTS["PHONE_AGENT_DEVICE_ID"]),
            lang=data.get("PHONE_AGENT_LANG", _DEFAULTS["PHONE_AGENT_LANG"]),
        )

    def to_export_lines(self) -> list[str]:
        return [
            "#!/bin/bash",
            "# AutoGLM Configuration - Generated by autoglm-web",
            f"export PHONE_AGENT_BASE_URL={_shell_single_quote(self.base_url)}",
            f"export PHONE_AGENT_MODEL={_shell_single_quote(self.model)}",
            f"export PHONE_AGENT_API_KEY={_shell_single_quote(self.api_key)}",
            f"export PHONE_AGENT_MAX_STEPS={_shell_single_quote(str(self.max_steps))}",
            f"export PHONE_AGENT_DEVICE_ID={_shell_single_quote(self.device_id)}",
            f"export PHONE_AGENT_LANG={_shell_single_quote(self.lang)}",
            "",
        ]

    def as_public_dict(self, mask_api_key: bool = True) -> dict[str, Any]:
        api_key = self.api_key
        if mask_api_key and api_key:
            if len(api_key) > 12:
                api_key = api_key[:6] + "******" + api_key[-4:]
            elif len(api_key) > 6:
                api_key = api_key[:3] + "***" + api_key[-3:]
            else:
                api_key = "***"
        return {
            "base_url": self.base_url,
            "model": self.model,
            "api_key": api_key,
            "max_steps": self.max_steps,
            "device_id": self.device_id,
            "lang": self.lang,
        }


_EXPORT_RE = re.compile(r"^\\s*export\\s+([A-Z0-9_]+)\\s*=\\s*(.*)\\s*$")


def read_config() -> AutoglmConfig:
    path = config_sh_path()
    if not path.exists():
        return AutoglmConfig.from_mapping(dict(_DEFAULTS))

    mapping: dict[str, str] = {}
    for raw in path.read_text(encoding="utf-8", errors="replace").splitlines():
        line = _strip_inline_comment(raw)
        if not line:
            continue
        m = _EXPORT_RE.match(line)
        if not m:
            continue
        key, value = m.group(1), m.group(2)
        mapping[key] = _parse_shell_concat(value)
    merged = dict(_DEFAULTS)
    merged.update(mapping)
    return AutoglmConfig.from_mapping(merged)


def write_config(updated: AutoglmConfig) -> None:
    path = config_sh_path()
    path.parent.mkdir(parents=True, exist_ok=True)
    content = "\n".join(updated.to_export_lines())
    path.write_text(content, encoding="utf-8")
    try:
        path.chmod(0o600)
    except Exception:
        pass


def config_exists() -> bool:
    return config_sh_path().exists()

